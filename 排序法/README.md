## 冒泡排序法
### 实现过程
从第一个元素开始，比较相邻元素的大小，若大小顺序有误，则对调后再进行下一个元素的比较，如此扫描过一次后就可确保最后一个元素位于正确的顺序，接着再逐步进行第二次扫描，直到完成所有元素的排序关系为止。
#### 举例：使用55、23、87、62、16数列来演示排序过程，从小到大排序，原始顺序为 55 23 87 62 16 
  （1）第一次扫描55和23比较，因为第二个元素23小，所以55和23进行互换。接着拿55和87比较，就这样一直比较并互换，到第4次比较完确定最大值在数组的最后。  <br>
  （2）第二次扫描也从头开始，但因为已确定最后一个元素是数组中的最大值，故只需比较3次。  <br>
  （3）第三次扫描完，完成三个值的排序。  <br>
  （4）第四次扫描完，即可完成全部的排序。  <br>
  总结：N个元素的冒泡排序法必须执行（N-1）次扫描，第一次扫描需要比较（N-1）次，共需比较（N-1）+(N-2)+...+1次。
### 代码实现
```python
#冒泡排序,（N）个元素必须执行（N-1）次扫描，第一次扫描需要比较（N-1）次，共比较（N-1）+（N-2）+...+1次
for i in range(7,-1,-1): #扫描次数
    for j in range(i):
        if data[j]>data[j+1]:
            data[j],data[j+1] = data[j+1],data[j]  #比较相邻两数，即第j和第j+1个数
    print('第%d次排序后的结果是:'%(8-i))  #将各次扫描后的结果打印出来
    for j in range(8):
        print('%3d'%data[j],end=' ')
print()
```

## 选择排序法
### 实现过程
选择排序法可使用两种方式排序，一种为在所有的数据中，按从大到小排序，将最大值放入第一个位置；一种从小到大排序，将最大值放入最后一个位置。例如，一开始在所有的数据中挑选一个最小项放在第一个位置（假设从小到大排序），再从第二项开始选一个最小项放在第二个位置，以此重复，直到完成排序为止。
### 代码实现
```python
def select(data):
    for i in range(7):
        for j in range(i+1,8):
            if data[i] > data[j]:  #比较第i和第j个元素
                data[i],data[j] = data[j],data[i]
    print()
```
#### 冒泡排序和选择排序的区别
冒泡排序：每次与相邻的两个元素比较，不合适就交换，依次向后。
选择排序：将第一个元素与后面的元素挨个轮流比较，如果按照从小到大的顺序，大的排序往后面。
选择排序可以看成是优化后的冒泡排序。

## 插入排序法
### 实现过程
插入排序法是将数组中的元素，逐一与已排序好的数据进行比较，前两个元素先排好，再将第三个元素插入适当的位置，所以这三个元素仍然是已排序好的，接着讲第四个元素加入，重复此步骤，直到排序完成为止。
### 代码实现
```python
def insert(data):
    for i in range(1,SIZE):  #SIZE为数组大小
        tmp = data[i]   #tmp用于存放当前的数值
        n0 = i-1  #设置当前值前一个元素的标识
        while n0>=0 and tmp<data[n0]:  #如果当前值小于前一个元素，就执行循环
            data[n0+1] = data[n0]   #当前值与前一个元素交换
            n0 = n0-1  #当前值前两个元素的标识（如果循环一次）
        data[n0+1] = tmp  #最小的元素放到第一个位置
```

## 快速排序法
### 实现过程
快速排序法又称分割交换排序法，是目前公认最佳的排序法，也是使用“分而治之”的方式。首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。操作与分割步骤如下：
假设有n项纪录R1、R2、R3...Rn，其键值为k1，k2，k3...kn:
（1）先假设K的值为第一个键值；
（2）从左到右找出键值Ki，使得Ki>K；
（3）从右到左找出键值Kj，使得Kj<K；
（4）如果i<j，那么Ki与Kj互换，并回到步骤（2）；
（5）若i>=j，那么K与Kj交换，并以j为基准点分割成左右两部分。然后针对左右两部分进行步骤（1）至（5），直到左半边键值等于右半边键值。

### 代码实现
```python
def kuaisu(d,size,lf,rg): #定义快速排序函数，第一项键值为 d[lf],size 为数组长度
     if lf<rg:  #排序数据的左边与右边
         lf_idx = lf+1  
         while d[lf_idx]<d[lf]:  #从左到右，找出大于键值K的“i”，其中键值K为d[lf]
             if lf_idx+1>size:
                break
             lf_idx += 1
         rg_idx = rg
         while d[rg_idx] > d[lf]: #从右向左，找出小于键值K的“j”
             rg_idx -=1
         while lf_idx < rg_idx:  # 假如 i<j
             d[lf_idx],d[rg_idx] = d[rg_idx],d[lf_idx]  #那么Ki与Kj互换
             lf_idx +=1  #回到步骤（2）
             while d[lf_idx]<d[lf]:
                lf_idx += 1
             rg_idx -= 1
             while d[rg_idx] >d[lf]:
                rg_idx -=1
         d[lf],d[rg_idx] = d[rg_idx],d[lf]  #直到i>+j,就将K与Kj交换
         
         kuaisu(d,size,lf,rg_idx-1)   #以rg_idx为基准点分成左右两半以递归方式
         kuaisu(d,size,rg_idx+1,rg)   #分别以左右两半进行排序直至完成排序
```





















